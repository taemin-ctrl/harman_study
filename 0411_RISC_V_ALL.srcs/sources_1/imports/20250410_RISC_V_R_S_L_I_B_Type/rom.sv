`timescale 1ns / 1ps

module rom (
    input  logic [31:0] addr,
    output logic [31:0] data
);
    logic [31:0] rom[0:127];

    initial begin
        $readmemh("code.mem",rom);
        //rom[x]=32'b fucn7 _ rs2 _ rs1 _f3 _ rd  _opcode; // R-Type
        //rom[0] = 32'b0000000_00001_00010_000_00100_0110011; // add x4, x2, x1
        //rom[1] = 32'b0100000_00001_00010_000_00101_0110011; // sub x5, x2, x1
        //rom[x]=32'b imm7  _ rs2 _ rs1 _f3 _ imm5_ opcode; // B-Type
        //rom[2] = 32'b0000000_00010_00010_000_01100_1100011; // beq x2, x2, 12 
        //rom[x]=32'b imm7  _ rs2 _ rs1 _f3 _ imm5_ opcode; // S-Type
        /*rom[0] = 32'b0000000_00010_00000_010_00100_0100011; // sw x2, 8(x0);
        rom[1] = 32'b0000000_00011_00000_000_01000_0100011; // sb x3, 4(x0);
        rom[2] = 32'b0000000_00100_00000_001_10000_0100011; // sh x4, 12(x0);
        //rom[x]=32'b imm12      _ rs1 _f3 _ rd  _ opcode; // L-Type
        rom[3] = 32'b000000000100_00000_010_00011_0000011; // lw x3, 4(x0);
        rom[4] = 32'b000000000100_00000_000_00100_0000011; // lb x4, 4(x0);
        rom[5] = 32'b000000010000_00000_001_00101_0000011; // lh x5, 12(x0);
        rom[6] = 32'b000000010000_00000_100_00110_0000011; // lbu x6, 12(x0);
        rom[7] = 32'b000000000100_00000_101_00111_0000011; // lhu x7, 4(x0);*/
        //rom[x]=32'b imm12      _ rs1 _f3 _ rd  _ opcode; // I-Type
        //rom[5] = 32'b000000000001_00000_000_00001_0010011; // addi x1, x0, 1;
        //rom[6] = 32'b000000000010_00001_001_00110_0010011; // slli x6, x1, 2;
        // 0: beq x1, x1, 8 (→ if true jump to rom[2])
/*rom[0] = 32'b0000000_00001_00001_000_01000_1100011;
// 1: nop (addi x0, x0, 0)
rom[1] = 32'b000000000000_00000_000_00000_0010011;

// 2: bne x1, x2, 8 (→ if true jump to rom[4])
rom[2] = 32'b0000000_00010_00001_001_01000_1100011;
// 3: nop
rom[3] = 32'b000000000000_00000_000_00000_0010011;

// 4: blt x1, x2, 8 (→ if true jump to rom[6])
rom[4] = 32'b0000000_00010_00001_100_01000_1100011;
// 5: nop
rom[5] = 32'b000000000000_00000_000_00000_0010011;

// 6: bge x2, x1, 8 (→ if true jump to rom[8])
rom[6] = 32'b0000000_00001_00010_101_01000_1100011;
// 7: nop
rom[7] = 32'b000000000000_00000_000_00000_0010011;

// 8: bltu x1, x2, 8 (→ if true jump to rom[10])
rom[8] = 32'b0000000_00010_00001_110_01000_1100011;
// 9: nop
rom[9] = 32'b000000000000_00000_000_00000_0010011;

// 10: bgeu x2, x1, 8 (→ if true jump to rom[12])
rom[10] = 32'b0000000_00001_00010_111_01000_1100011;
// 11: nop
rom[11] = 32'b000000000000_00000_000_00000_0010011;

// 12: 종료 혹은 다음 로직
rom[12] = 32'b000000000000_00000_000_00000_0010011; // nop*/

        //rom[0] = 32'b00000000000000001100000100110111;
        //rom[1] = 32'b00000000000000001100000100010111;
        //rom[0] = 32'b000000001000_00010_000_00001_1100111;
        //rom[5] = 32'b00000000110000000000000101101111;
        
        /*rom[0] = 32'b0000000_00001_00010_000_00100_0110011; // add x4, x2, x1;
        rom[1] = 32'b0100000_00001_00010_000_00101_0110011; // sub x5, x2, x1; 
        rom[2] = 32'b0000000_00001_00010_001_00110_0110011; // sll x6, x2, x1;
        rom[3] = 32'b0000000_00001_00010_101_00111_0110011; // srl x7, x2, x1;
        rom[4] = 32'b0100000_00001_00010_101_01000_0110011; // sra x8, x2, x1;
        rom[5] = 32'b0000000_00001_00010_010_01001_0110011; // slt x9, x2, x1;
        rom[6] = 32'b0000000_00001_00010_011_01010_0110011; // sltu x10, x2, x1;
        rom[7] = 32'b0000000_00001_00010_100_01011_0110011; // xor x11, x2, x1;
        rom[8] = 32'b0000000_00001_00010_110_01100_0110011; // or x12, x2, x1;
        rom[9] = 32'b0000000_00001_00010_111_01101_0110011; // and x13, x2, x1;*/

        /*rom[0] = 32'b000000000101_01010_000_00001_0010011; // addi x1, x10, 5     => x1 = 10 + 5 = 15
        rom[1] = 32'b000000000001_01010_010_00010_0010011; // slti x2, x10, 1     => x2 = (10 < 1)? 1 : 0 = 0
        rom[2] = 32'b000000000001_01010_011_00011_0010011; // sltiu x3, x10, 1    => x3 = (10 < 1)? 1 : 0 = 0
        rom[3] = 32'b000000001010_01010_100_00100_0010011; // xori x4, x10, 10    => x4 = 10 ^ 10 = 0
        rom[4] = 32'b000000001010_01010_110_00101_0010011; // ori x5, x10, 10     => x5 = 10 | 10 = 10
        rom[5] = 32'b000000001010_01010_111_00110_0010011; // andi x6, x10, 10    => x6 = 10 & 10 = 10
        rom[6] = 32'b000000_000010_01010_001_00111_0010011; // slli x7, x10, 2     => x7 = 10 << 2 = 40
        rom[7] = 32'b000000_000010_01010_101_01000_0010011; // srli x8, x10, 2     => x8 = 10 >> 2 = 2
        rom[8] = 32'b010000_000010_01010_101_01001_0010011; // srai x9, x10, 2     => x9 = 10 >> 2 (arith) = 2
    */
    end
    assign data = rom[addr[31:2]];
endmodule
