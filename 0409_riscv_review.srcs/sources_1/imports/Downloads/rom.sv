`timescale 1ns / 1ps

module rom (
    input  logic [31:0] addr,
    output logic [31:0] data
);
    logic [31:0] rom[0:20];

    initial begin
        //rom[x]=32'b fucn7 _ rs2 _ rs1 _f3 _ rd  _opcode; // R-Type
        /*rom[0] = 32'b0000000_00001_00010_000_00100_0110011; // add x4, x2, x1
        rom[1] = 32'b0100000_00001_00010_000_00101_0110011; // sub x5, x2, x1
        //rom[x]=32'b immm7 _ rs2 _ rs1 _f3 _ imm5_opcode; // S-Type
        rom[2] = 32'b0000000_00010_00000_010_01000_0100011; // sw x2, 8(x0); 
        //rom[x]=32'b immm7      _ rs1 _f3 _ rd  _opcode; // L-Type
        rom[3] = 32'b000000001000_00000_010_00011_0000011; // lw x3, 8(x0);

        // temp code
        rom[4] = 32'b0000000_00001_00000_000_00110_0100011; // sb x1, 6(x0)
        rom[5] = 32'b0000000_00010_00000_001_01000_0100011; // sh x2, 8(x0)
        rom[6] = 32'b000000000110_00000_000_00011_0000011;  // lb x3, 6(x0)
        rom[7] = 32'b000000001000_00000_001_00011_0000011;  // lh x4, 8(x0)*/
        // I-type: addi x1, x0, 5   => x1 = 5
        // I-type 예제
        /*rom[0] = 32'b000000000101_01010_000_00001_0010011; // addi x1, x10, 5     => x1 = 10 + 5 = 15
        rom[1] = 32'b000000000001_01010_010_00010_0010011; // slti x2, x10, 1     => x2 = (10 < 1)? 1 : 0 = 0
        rom[2] = 32'b000000000001_01010_011_00011_0010011; // sltiu x3, x10, 1    => x3 = (10 < 1)? 1 : 0 = 0
        rom[3] = 32'b000000001010_01010_100_00100_0010011; // xori x4, x10, 10    => x4 = 10 ^ 10 = 0
        rom[4] = 32'b000000001010_01010_110_00101_0010011; // ori x5, x10, 10     => x5 = 10 | 10 = 10
        rom[5] = 32'b000000001010_01010_111_00110_0010011; // andi x6, x10, 10    => x6 = 10 & 10 = 10
        rom[6] = 32'b000000_000010_01010_001_00111_0010011; // slli x7, x10, 2     => x7 = 10 << 2 = 40
        rom[7] = 32'b000000_000010_01010_101_01000_0010011; // srli x8, x10, 2     => x8 = 10 >> 2 = 2
        rom[8] = 32'b010000_000010_01010_101_01001_0010011; // srai x9, x10, 2     => x9 = 10 >> 2 (arith) = 2

        // 저장 (store) 명령어: 주소 = x10 + offset
// store 명령어들
rom[9] = 32'b0000000_00001_00010_000_01000_0100011; // sb x1, 0(x10)  → RAM[0] = 0x01
rom[10] = 32'b0000000_00110_00000_001_00100_0100011; // sh x2, 1(x10)  → RAM[1] = 0x0002
rom[11] = 32'b0000000_00011_00000_010_1000_0100011; // sw x3, 2(x10)  → RAM[2] = 0x00000003

// load 명령어들
rom[12] = 32'b000000001000_00000_000_01110_0000011; // lb  x14, 0(x10) → x14 = 0x00000001
rom[13] = 32'b000000001000_00000_001_01111_0000011; // lh  x15, 1(x10) → x15 = 0x00000002
rom[14] = 32'b000000000100_00000_010_10000_0000011; // lw  x16, 2(x10) → x16 = 0x00000003
rom[15] = 32'b000000000100_00000_100_10001_0000011; // lbu x17, 0(x10) → x17 = 0x00000001
rom[16] = 32'b000000001000_00000_101_00110_0000011; // lhu x18, 1(x10) → x18 = 0x00000002*/

// 초기값 설정
// x10 = 20
rom[0]  = 32'b000000001010_00000_000_01010_0010011; // addi x10, x0, 20

// x1 = 0xAA (170)
rom[1]  = 32'b000000001010_00000_000_00001_0010011; // addi x1, x0, 170

// x2 = 0x2BC (700)
rom[2]  = 32'b000101011100_00000_000_00010_0010011; // addi x2, x0, 700

// x3 = -0xF10 (0xFFFF00F0)
rom[3]  = 32'b111100001000_00000_000_00011_0010011; // addi x3, x0, -0xF10 = 0xFFFF00F0

// Store 명령어
rom[4]  = 32'b0000000_00001_01010_000_00000_0100011; // sb  x1, 0(x10)   → RAM[20] = 0xAA
rom[5]  = 32'b0000000_00010_01010_001_00110_0100011; // sh  x2, 4(x10)   → RAM[24] = 0x02BC
rom[6]  = 32'b0000000_00011_01010_010_01000_0100011; // sw  x3, 8(x10)   → RAM[28] = 0xFFFF00F0

// Load 명령어
rom[7]  = 32'b000000000000_01010_000_01110_0000011; // lb  x14, 0(x10)   → x14 = 0xFFFFFFAA
rom[8]  = 32'b000000001000_01010_001_01111_0000011; // lh  x15, 4(x10)   → x15 = 0x000002BC
rom[9]  = 32'b000000010000_01010_010_10000_0000011; // lw  x16, 8(x10)   → x16 = 0xFFFF00F0
rom[10] = 32'b000000000000_01010_100_10001_0000011; // lbu x17, 0(x10)   → x17 = 0x000000AA
rom[11] = 32'b000000001000_01010_101_10010_0000011; // lhu x18, 4(x10)   → x18 = 0x000002BC


    end
    assign data = rom[addr[31:2]];
endmodule
