module Instruction_Memory (
    input  logic [31:0] instr_mem_addr,
    output logic [31:0] instr_code
);
    
    logic [31:0] rom[0:127];

    initial begin
    
        // rom[x] = 32'b func7 _ rs2 _ rs1 _ func3 _ rd _ opcode;   // R-Type
        // rom[x] = 32'b imm12 _ rs1 _ func3 _ rd _ opcode;   // L-Type
        // rom[x] = 32'b imm12 _ rs1 _ func3 _ rd _ opcode;   // I-Type
        // rom[x] = 32'b func7 _ shamt _ rs1 _ func3 _ rd _ opcode;   // I-Type
        // rom[x] = 32'b imm7 _ rs2 _ rs1 _ f3 _ imm5 _ opcode;     // S-Type
        // rom[x] = 32'b imm7 _ rs2 _ rs1 _ f3 _ imm5 _ opcode;     // B-Type
        // rom[x] = 32'b imm20 _ rd _ opcode;     // LU_TYPE
        // rom[x] = 32'b imm20 _ rd _ opcode;     // AU_TYPE
        // rom[x] = 32'b imm[20][10:1][11][19:12] _ rd _ opcode;     // J_TYPE
        // rom[x] = 32'b imm12 _ rs1 _ f3 _ rd _ opcode;     // JL_TYPE
      
        // R-Type (rd = x7, rs1 = x2 = 2, rs2 = x1 = 1)
        rom[0] = 32'b0000000_00001_00010_000_00111_0110011; // ADD  x7, x2, x1   ; x7 = 2 + 1 = 3
        rom[1] = 32'b0100000_00001_00010_000_00111_0110011; // SUB  x7, x2, x1   ; x7 = 2 - 1 = 1
        rom[2] = 32'b0000000_00001_00010_001_00111_0110011; // SLL  x7, x2, x1   ; x7 = 2 << 1 = 4
        rom[3] = 32'b0000000_00001_00010_101_00111_0110011; // SRL  x7, x2, x1   ; x7 = 2 >> 1 = 1
        rom[4] = 32'b0100000_00001_00010_101_00111_0110011; // SRA  x7, x2, x1   ; x7 = 2 >>> 1 = 1 (��� ����Ʈ)

        rom[5] = 32'b0000000_00101_00010_010_00111_0110011; // SLT  x7, x2, x5   ; x7 = (2 < -3) = 0 (signed)
        rom[6] = 32'b0000000_00101_00010_011_00111_0110011; // SLTU x7, x2, x5   ; x7 = (2 < 0xFFFFFFFD) = 1 (unsigned)

        rom[7] = 32'b0000000_00001_00010_100_00111_0110011; // XOR  x7, x2, x1   ; x7 = 2 ^ 1 = 3
        rom[8] = 32'b0000000_00001_00010_110_00111_0110011; // OR   x7, x2, x1   ; x7 = 2 | 1 = 3
        rom[9] = 32'b0000000_00001_00010_111_00111_0110011; // AND  x7, x2, x1   ; x7 = 2 & 1 = 0

        // L-Type (rs1 = x2 = 2, offset = 2)
        rom[10] = 32'b000000000010_00010_000_01000_0000011; // LB   x8, 2(x2)    ; x8 = M[1][0:7]
        rom[11] = 32'b000000000010_00010_001_01000_0000011; // LH   x8, 2(x2)    ; x8 = M[1][0:15]
        rom[12] = 32'b000000000010_00010_010_01000_0000011; // LW   x8, 2(x2)    ; x8 = M[1][0:31]
        rom[13] = 32'b000000000010_00010_100_01000_0000011; // LBU  x8, 2(x2)    ; x8 = M[1][0:7], zero-extend
        rom[14] = 32'b000000000010_00010_101_01000_0000011; // LHU  x8, 2(x2)    ; x8 = M[1][0:15], zero-extend

        // I-Type (rs1 = x2 = 2)
        rom[15] = 32'b000000000100_00010_000_01001_0010011; // ADDI  x9, x2, 4   ; x9 = 2 + 4 = 6

        rom[16] = 32'b111111110101_00010_010_01001_0010011; // SLTI  x9, x2, -3  ; x9 = (2 < -3) = 0 (signed)
        rom[17] = 32'b111111110101_00010_011_01001_0010011; // SLTIU x9, x2, -3  ; x9 = (2 < 0xFFFFFFFD) = 1 (unsigned)

        rom[18] = 32'b000000000100_00010_100_01001_0010011; // XORI  x9, x2, 4   ; x9 = 2 ^ 4 = 6
        rom[19] = 32'b000000000100_00010_110_01001_0010011; // ORI   x9, x2, 4   ; x9 = 2 | 4 = 6
        rom[20] = 32'b000000000100_00010_111_01001_0010011; // ANDI  x9, x2, 4   ; x9 = 2 & 4 = 0

        // I-Type Shift
        rom[21] = 32'b0000000_00100_00010_001_01010_0010011; // SLLI  x10, x2, 4  ; x10 = 2 << 4 = 32
        rom[22] = 32'b0000000_00001_00100_101_01010_0010011; // SRLI  x10, x2, 4  ; x10 = 4 >> 1 = 2
        rom[23] = 32'b0100000_00001_00100_101_01010_0010011; // SRAI  x10, x2, 4  ; x10 = 4 >>> 1 = 2

        // S-Type (rs1 = x2 = 2, rs2 = x1 = 1, imm = 4)
        rom[24] = 32'b0000000_00001_00010_000_00010_0100011; // SB  x1 �� 2(x2)    ; M[1] = x1[7:0]
        rom[25] = 32'b0000000_00001_00010_001_00010_0100011; // SH  x1 �� 2(x2)    ; M[1] = x1[15:0]
        rom[26] = 32'b0000000_00001_00010_010_00010_0100011; // SW  x1 �� 2(x2)    ; M[1] = x1

        // B-Type (offset = 8 �� PC + 8 �� +2 instruction)
        rom[29] = 32'b0000000_00011_00010_000_01000_1100011; // BEQ  x2, x3, 8    ; 2 == 2 �� �� �� PC += 8
        rom[30] = 32'b0000000_00011_00100_001_01000_1100011; // BNE  x4, x3, 8    ; 3 != 2 �� �� �� PC += 8
        rom[31] = 32'b0000000_00101_00110_100_01000_1100011; // BLT  x5, x6, 8    ; -4 < -3 �� �� �� PC += 8 
        rom[32] = 32'b0000000_00110_00101_101_01000_1100011; // BGE  x6, x5, 8    ; -3 �� -4 �� �� �� PC += 8
        rom[33] = 32'b0000000_00100_00011_110_01100_1100011; // BLTU x3, x4, 8    ; 2 < 3 �� �� �� PC += 12
        rom[34] = 32'b0000000_00100_00011_111_01000_1100011; // BGEU x4, x3, 8    ; 2 �� 3 �� ���� �� PC += 4

        // U-Type
        rom[27] = 32'b00000000000000000001_01011_0110111;   // LUI   x11, 1      ; x11 = 1 << 12 = 0x1000
        rom[28] = 32'b00000000000000000001_01011_0010111;   // AUIPC x11, 1      ; x11 = PC + 0x1000

        // J-Type
        rom[35] = 32'b000000000000_00000_000_01011_1100111; // JALR x11, 0(x0)   ; x11 = PC+4, PC = x0 + 0 �� 0
        rom[36] = 32'b00000000100000000000_01011_1101111;   // JAL x11, 8      ; x11 = PC+4, PC += 8
        rom[38] = 32'b000001111000_00000_000_01011_1100111; // JALR x11, 120(x0)   ; x11 = PC+4, PC = x0 + 120 �� 120

        //$readmemh("code.mem", rom);
    end               

    assign instr_code = rom[instr_mem_addr[31:2]];

endmodule